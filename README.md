# `java-filmorate`
Template repository for `Filmorate` project.

# Техническое задание 12-го спринта.  
Ура, практика!  
Пришло время усовершенствовать `Filmorate` с помощью 
полученных знаний о базах данных. На этот раз вы добавите ещё одну 
функциональность — сохранение состояния данных после перезапуска. 
Уже к концу задания у вас будет завершённое приложение для работы
с фильмами и оценками пользователей. Внимание, мотор!


## Организация  
В этом спринте вы будете работать в новой ветке. Назовите её add-database. 
Название ветки важно, потому что к ней привязаны тесты.

## Создание базы данных  

В уроках спринта вы использовали PostgreSQL — популярную в индустрии базу данных. 
Однако сейчас вы будете работать с другой базой. Она называется **H2**.  
**H2** не требует отдельной установки. Её можно встроить в приложение — достаточно 
добавить зависимость в сборку проекта. Использование встроенной базы данных упростит 
тестирование вашего приложения в GitHub.  

#### База будет работать в двух режимах:  
* В режиме тестирования H2 будет хранить данные в памяти. Это позволит базе быстро 
запуститься на время тестов и удалить все тестовые данные после их завершения.
* В рабочем режиме H2 будет хранить данные в файле на жёстком диске. Это не позволит 
рабочим данным потеряться между запусками.  

Почитайте, как использовать H2 со **Spring Boot**, в этой [статье](https://www.baeldung.com/spring-boot-h2-database).  
Далее следуйте нашей инструкции:
1. Добавьте в проект зависимости
   1. `com.h2database.h2`,
   2. `org.springframework.boot.spring-boot-starter-data-jdbc`
   3. `org.springframework.boot.spring-boot-starter-test`.  
2. Сконфигурируйте базу данных для рабочего режима с помощью файла настроек `application.properties`.


```properties
spring.sql.init.mode=always
# в jdbc-url укажите, что данные нужно сохранять в файл
spring.datasource.url=jdbc:h2:file:./db/filmorate
spring.datasource.driverClassName=org.h2.Driver
spring.datasource.username=sa
spring.datasource.password=password
```
3. Сформируйте структуру базы данных — для этого реализуйте схему, которую вы нарисовали
в предыдущем спринте. Обратите внимание: база будет работать, пока работает само 
приложение. Чтобы подключиться к БД напрямую, используйте **встроенный в** IntelliJ IDEA 
функционал или **клиент _DBeaver_**.  

4. Не забудьте обновить модели данных в коде — добавьте новые поля.
5. Соберите SQL-запросы, формирующие структуру вашей базы, в отдельный файл 
в `src/main/resources` с названием schema.sql — так схема будет создаваться заново
при каждом запуске приложения.

### Подсказка: про файл `schema.sql`  
Включите в файл `schema.sql` создание таблиц. Если вам нужны некоторые данные в базе, их 
инициализация обычно описывается в файле `data.sql` — создайте его там же, где и schema.sql.
Чтобы избежать ошибок, связанных с многократным применением скрипта к БД, добавьте 
условие `IF NOT EXISTS` при создании таблиц и индексов.
## Работа с DAO  
Таблицы созданы. Теперь можно заняться кодом, который будет отвечать за получение 
данных из базы.
1. Вам пригодятся созданные ранее интерфейсы `UserStorage` и `FilmStorage`.
Напишите для них новую имплементацию — например, `UserDbStorage` и `FilmDbStorage`. Эти
классы будут `DAO` — объектами доступа к данным.  
2. Напишите в DAO соответствующие мапперы и методы, позволяющие сохранять пользователей
и фильмы в базу данных и получать их из неё.    
***
### Подсказка: про аннотацию `@Qualifier`  
Чтобы Spring мог работать с новыми компонентами и отличать их от старых хранилищ, 
воспользуйтесь аннотацией `@Qualifier`. Пример её использования можно найти 
в этой [статье](https://www.baeldung.com/spring-qualifier-annotation).
***
### Подсказка: как проверить, что база данных успешно настроена  
Убедитесь, что ваше приложение работает с базой данных. Создайте новый фильм и
пользователя, а потом перезапустите проект — данные должны сохраниться в базе 
и быть доступны после перезапуска.
***
### Подсказка: как реализовать **CRUD**-операции с использованием **JdbcTemplate**
В теме о работе с БД вы узнали, как делать выборку данных из базы с помощью SQL-запросов
и **JdbcTemplate**. Для реализации методов, описанных в интерфейсах хранилищ, вам 
также потребуется добавлять новые данные и обновлять имеющиеся.  
Почитайте, как это сделать, [в этой статье](https://springframework.guru/spring-jdbctemplate-crud-operations/).  

## @Тестирование
Тестировать приложение вручную — трудоёмкий процесс, который сопряжён со многими 
ограничениями. Использовать Postman-запросы проще, но такой способ не позволяет 
протестировать имплементацию методов.  

Вам предстоит реализовать **интеграционное тестирование** (англ. _integration testing_).  

С помощью него можно проверить работу приложения с зависимостями — например, с базой 
данных. Резидентная база данных обеспечит автономность ваших интеграционных 
тестов — перед каждым их запуском Spring будет создавать новую, чистую БД.  

Подробнее об этом виде тестирования мы расскажем в следующем модуле, но простейшую 
его реализацию вы выполните уже сейчас.
```java
@SpringBootTest
@AutoConfigureTestDatabase
@RequiredArgsConstructor(onConstructor_ = @Autowired)
class FilmoRateApplicationTests {
private final UserDbStorage userStorage;

    @Test
    public void testFindUserById() {

        Optional<User> userOptional = userStorage.findUserById(1);

        assertThat(userOptional)
                .isPresent()
                .hasValueSatisfying(user ->
                        assertThat(user).hasFieldOrPropertyWithValue("id", 1)
                );
    }
}
```

Обратите внимание:
1. по аннотации `@AutoConfigureTestDatabase Spring` понимает, что перед запуском теста
необходимо сконфигурировать тестовую БД вместо основной;
2. аннотация `@SpringBootTest,` которой помечается класс с тестами, говорит о том, 
что перед запуском этих тестов необходим запуск всего приложения;
3. аргумент аннотации `@RequiredArgsConstructor` указывает, что конструктор, созданный 
с помощью библиотеки Lombok, сможет получать зависимости через механизм `@Autowired`.


Во время инициализации тестовой базы данных Spring прочитает SQL-запросы из стандартного
файла `schema.sql,` который вы собрали в начале задания, и выполнит их для текущей базы
данных. Этот скрипт должен создать схему в тестовой БД.  

Теперь можно написать интеграционные тесты для DAO-объектов приложения по примеру выше. 
С помощью них вы проверите, правильно ли работают ваши запросы к базе данных.
Убедитесь, что все публичные методы хранилища покрыты тестами.


## Доработка бизнес-логики  

Осталось несколько штрихов. Добавьте в код недостающие DAO-объекты, соответствующие 
вашей схеме, и завершите описание бизнес-логики. После этого протестируйте поведение 
программы.  

Поскольку в программе появились новые сущности, то нужно обеспечить доступ к ним. 
Добавьте следующие эндпоинты:
1. Для получения списка всех жанров и по идентификатору.
```jql
GET /genres
GET /genres/{id}
```
// Пример возвращаемого значения
```jsonpath
{
“id”: 1,
“name”: “Комедия”
}
```
2. Для получения жанра и рейтинга по идентификатору:
```jql
GET /mpa
GET /mpa/{id}
```
// Пример возвращаемого значения
```jsonpath
{
“id”: 1,
“name”: “G”
}
```

При создании и получении фильмов достаточно передать список идентификаторов жанров и 
идентификатор рейтинга. Эти же данные должны передаваться при обновлении, создании и 
получении фильмов — если нужно, обновите эти эндпоинты.  

И последнее небольшое изменение: дружба должна стать односторонней. Это значит, что
если какой-то пользователь оставил вам заявку в друзья, то он будет в списке ваших
друзей, а вы в его — нет.  
***
### Подсказка-напоминание
Не забудьте: у пользователей Filmorate должна быть возможность лайкать фильмы и 
добавлять друг друга в друзья с подтверждением дружбы.
***
## Финальный кадр
Убедитесь, что ваше приложение работает правильно. Проверьте его дополнительно с помощью
тестов Postman: [sprint.json](https://github.com/yandex-praktikum/java-filmorate/blob/add-database/postman/sprint.json).

⚠️ Эти же тесты запускаются в GitHub при создании pull request’а. Проверьте их 
локально, прежде чем делать pull request.  

Поздравляем! У вас получилось полноценное приложение, которое умеет обрабатывать и 
хранить данные о пользователях и их любимых фильмах. Выбрать что-нибудь для просмотра 
за ужином больше не составит труда. Вы снова на высоте. Хеппи-энд и титры!



***
***
***
***
Изменена ветка для самопроверки на add-database-diagram
## Sprint 11 Final. round 1.   
### Film
#### Добавьте новое свойство — «жанр».  
У фильма может быть сразу несколько жанров, а у поля — несколько значений. Например, таких:  
* Комедия.
* Драма.
* Мультфильм.
* Триллер.
* Документальный.
* Боевик.

#### Ещё одно свойство — рейтинг Ассоциации кинокомпаний (англ. Motion Picture Association, сокращённо МРА).   
Эта оценка определяет возрастное ограничение для фильма. Значения могут быть следующими:
* `G` — у фильма нет возрастных ограничений,
* `PG` — детям рекомендуется смотреть фильм с родителями,
* `PG-13` — детям до 13 лет просмотр не желателен,
* `R` — лицам до 17 лет просматривать фильм можно только в присутствии взрослого,
* `NC-17` — лицам до 18 лет просмотр запрещён.  

### User
Добавьте статус для связи «дружба» между двумя пользователями:
* неподтверждённая — когда один пользователь отправил запрос на добавление другого пользователя в друзья,
* подтверждённая — когда второй пользователь согласился на добавление.
### Создание схемы базы данных   
Начните с таблиц для хранения пользователей и фильмов. При проектировании помните о том, что:
   1. Каждый столбец таблицы должен содержать только одно значение.
   2. Хранить массивы значений или вложенные записи в столбцах нельзя.
   3. Все неключевые атрибуты должны однозначно определяться ключом.
   4. Все неключевые атрибуты должны зависеть только от первичного ключа, а не от других неключевых атрибутов.
   5. База данных должна поддерживать бизнес-логику предусмотренную в приложении.   
      Подумайте о том, как будет происходить получение всех фильмов, пользователей. 
      А как — топ N наиболее популярных фильмов. Или список общих друзей с другим пользователем.

### Теперь нарисуйте схему базы данных.   
**На рисунке дополнительно отображены переменные Java-программы, которые будут связаны с БД.**  

![DiagrammBD.png](DiagrammBD.png)   


### Проверка статус друга:  
`"В друзьях ли люди"` буду проверять по поиску в таблице `idsFriends`.
При первом запросе определяю строки с ID юзера 1.
Получается список ID тех, кому юзер 1 отправил запросы.
Второй заход будет идти по уникальной паре составного ключа. ID юзера 2 - ID юзера 1.  

Если есть такая запись, значит юзер 1 и юзер 2 в друзьях друг у друга.
Если нет, то второй друг не подтвердил запрос.

Список тех, кто отправил запрос в друзья, но не был добавлен будет определяться по запросу таблицы,
которая получится при поиске по БД:   
**Запрос:** поиск запросов тех, кто отправил юзеру 1 запрос в друзья.  
При условии наличия ответного запроса не включаем в результаты ID юзеров.

### С жанрами и рейтингом MPA фильмов будет проще, чем с друзьями юзеров.

  ## Sprint 10 Final. round 2.  
### Проект сдан и имеет следующий функционал:
* Новая архитектура приложения.
* Закомментированы файлы тестов контроллеров.
* Обработка ошибок с помощью ExceptionHandler.
* Юзеры добавляются и удаляются из друзей.
* Фильмам ставятся и удаляются лайки.
* Тесты Mockito так и не настроены.

# Финальный проект спринта 10.
## Техническое задание.
Настало время улучшить `Filmorate`. Чтобы составлять рейтинг фильмов, нужны отзывы пользователей. А для улучшения 
рекомендаций по просмотру хорошо бы объединить пользователей в комьюнити.  
По итогам прошлого спринта у вас получилась заготовка приложения. 
Программа может принимать, обновлять и возвращать пользователей и фильмы.  
В этот раз улучшим `API` приложения до соответствия `REST`, а также изменим архитектуру приложения 
с помощью внедрения зависимостей.  
#### Наводим порядок в репозитории:  
* Для начала убедитесь в том, что ваша работа за предыдущий спринт слита с главной веткой main. 
* Создайте новую ветку, которая будет называться `add-friends-likes`.  
* Название ветки важно сохранить, потому что оно влияет на запуск тестов в GitHub.  
### Подсказка: про работу в `Git`.
Для слияния веток используйте команду merge.
## Архитектура:
Начнём с переработки архитектуры.  
Сейчас вся логика приложения спрятана в контроллерах — изменим это. Вынесите хранение данных 
о фильмах и пользователях в отдельные классы. Назовём их «хранилищами» (англ. `storage`) — так 
будет сразу понятно, что они делают.
* Создайте интерфейсы `FilmStorage` и `UserStorage`, в которых будут определены методы добавления, 
удаления и модификации объектов.
* Создайте классы `InMemoryFilmStorage` и `InMemoryUserStorage`, имплементирующие новые интерфейсы, 
и перенесите туда всю логику хранения, обновления и поиска объектов.
* Добавьте к `InMemoryFilmStorage` и `InMemoryUserStorage` аннотацию `@Component,` чтобы 
впоследствии пользоваться внедрением зависимостей и передавать хранилища сервисам.
### Подсказка: про структуру проекта.
Чтобы объединить хранилища, создайте новый пакет storage. В нём будут только классы и интерфейсы, 
имеющие отношение к хранению данных. Например, `ru.yandex.filmorate.storage.film.FilmStorage`.

## Новая логика.
Пока у приложения нет никакой бизнес-логики, кроме валидации сущностей. Обеспечим возможность 
пользователям добавлять друг друга в друзья и ставить фильмам лайки.
* Создайте `UserService`, который будет отвечать за такие операции с пользователями, 
как добавление в друзья, удаление из друзей, вывод списка общих друзей. 
Пока пользователям не надо одобрять заявки в друзья — добавляем сразу. 
То есть если Лена стала другом Саши, то это значит, что Саша теперь друг Лены.
* Создайте `FilmService`, который будет отвечать за операции с фильмами, — добавление и 
удаление лайка, вывод 10 наиболее популярных фильмов по количеству лайков. Пусть пока каждый 
пользователь может поставить лайк фильму только один раз.
* Добавьте к ним аннотацию `@Service` — тогда к ним можно будет получить доступ из контроллера.
### Подсказка: ещё про структуру.
По аналогии с хранилищами, объедините бизнес-логику в пакет `service`.
### Подсказка: про список друзей и лайки.
Есть много способов хранить информацию о том, что два пользователя являются друзьями. Например, 
можно создать свойство `friends` в классе пользователя, которое будет содержать список его друзей. 
Вы можете использовать такое решение или придумать своё. Для того чтобы обеспечить уникальность 
значения (мы не можем добавить одного человека в друзья дважды), проще всего использовать для 
хранения `Set<Long>` с `id` друзей. Таким же образом можно обеспечить условие «один пользователь — 
один лайк» для оценки фильмов.
### Зависимости.
Переделайте код в контроллерах, сервисах и хранилищах под использование внедрения зависимостей.
* Используйте аннотации `@Service`, `@Component`, `@Autowired`. Внедряйте зависимости через 
конструкторы классов.
* Классы-сервисы должны иметь доступ к классам-хранилищам. Убедитесь, что сервисы зависят от 
интерфейсов классов-хранилищ, а не их реализаций. Таким образом в будущем будет проще добавлять 
и использовать новые реализации с другим типом хранения данных.
* Сервисы должны быть внедрены в соответствующие контроллеры.

### Подсказка: `@Service vs @Component`.
`@Component` — аннотация, которая определяет класс как управляемый Spring. Такой класс будет 
добавлен в контекст приложения при сканировании.  
`@Service` не отличается по поведению, но обозначает более узкий спектр классов — такие, 
которые содержат в себе бизнес-логику и, как правило, не хранят состояние.
## Полный `REST`.
Дальше стоит заняться контроллерами и довести `API` до соответствия `REST`.
* С помощью аннотации `@PathVariable` добавьте возможность получать каждый фильм и данные о 
пользователях по их уникальному идентификатору: `GET .../users/{id}`.
* Добавьте методы, позволяющие пользователям добавлять друг друга в друзья, получать список 
общих друзей и лайкать фильмы. Проверьте, что все они работают корректно.
* `PUT /users/{id}/friends/{friendId}` — добавление в друзья.
* `DELETE /users/{id}/friends/{friendId}` — удаление из друзей.
* `GET /users/{id}/friends` — возвращаем список пользователей, являющихся его друзьями.
* `GET /users/{id}/friends/common/{otherId}` — список друзей, общих с другим пользователем.
* `PUT /films/{id}/like/{userId}` — пользователь ставит лайк фильму.
* `DELETE /films/{id}/like/{userId}` — пользователь удаляет лайк.
* `GET /films/popular?count={count}` — возвращает список из первых count фильмов по количеству 
лайков. Если значение параметра `count` не задано, верните первые 10.
* Убедитесь, что ваше приложение возвращает корректные `HTTP`-коды.
* `400` — если ошибка валидации: `ValidationException`;
* `404` — для всех ситуаций, если искомый объект не найден;
* `500` — если возникло исключение.
### Подсказка:
Настройте `ExceptionHandler` для централизованной обработки ошибок.
## Тестирование
Убедитесь, что приложение работает, — протестируйте его с помощью Postman: postman.json.  


Ого! Оцените, как `Filmorate` быстро растёт, — все компоненты занимают свои места, проявляется 
настоящая бизнес-логика. Любители кино потирают руки. Удачной разработки!


# Некоторые алгоритмы работы программы:
###    Обновление пользователя.
    Пользователь есть в БД по логину?
       да: {
            ID не равен null или совпадает с ID из БД   {
                если ID пользователя == null   {
                    присваиваем ID из БД пользователю.
                    обновляем запись в БД.
                    Return Ok.
                } иначе {
                    если ID совпадает с ID из БД {
                        обновляем запись в БД.
                        Return Ok.
                    } иначе {
                        Bad Request 500, Not Found 404
                    }
                }
            }
       Нет: {
            если нет ID {
                присваиваем сгенерированный ID;
                вносим в БД
                return OK.
            } иначе если ID есть в БД {
                обновление логина пользователя.
                обновляем запись в БД.
            } иначе если ID нет в БД {
                Bad Request 500, Not Found 404
            }
        }
